package com.example.imagesteganography;


import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.Log;

import java.util.Collections;

public class LSBImageStego {

    private Bitmap coverImage;
    private String secretMessage;
    private String Binary_OF_SecretMessage;
    private int originalSecretMessageLength;
    private int coverImage_rows;
    private int coverImage_columns;


    /**
     *
     * @param coverImage Bitmap Image obtained by the Uri generated by the User Selection
     * @param secretMessage Secret Message,which the User wants to Encode into the Image
     * @description This Constructor should be called for Encoding
     */
    public LSBImageStego(Bitmap coverImage , String secretMessage){
        this.coverImage = coverImage.copy(Bitmap.Config.ARGB_8888 , true);
        this.coverImage_rows = this.coverImage.getHeight();
        this.coverImage_columns =  this.coverImage.getWidth();
        this.secretMessage = secretMessage;
        this.originalSecretMessageLength = this.secretMessage.length();
        this.makeBinaryStringFromMessage();
//        Log.i("URI" ,new Integer(this.coverImage_rows).toString());
//        Log.i("URI" , new Integer(this.coverImage_columns).toString());
//        Log.i("URI" , this.secretMessage);
//        Log.i("URI", new Integer(this.originalSecretMessageLength).toString());
    }

    /**
     *
     * @return
     * @description getter
     */
    public Bitmap getCoverImage(){
        return this.coverImage;
    }

    /**
     *
     * @return
     * @description getter
     */
    public String getSecretMessage(){
        return this.secretMessage;
    }

    /**
     *
     * @param coverImage  Bitmap Image obtained by the Uri generated by the User Selection
     * @description This Constructor should be called for Decoding
     */
    public LSBImageStego(Bitmap coverImage){
        this.coverImage = coverImage.copy(Bitmap.Config.ARGB_8888 , true);
        this.coverImage_rows = this.coverImage.getHeight();
        this.coverImage_columns =  this.coverImage.getWidth();
    }

    /**
     * @description This method should be called for Decoding the Message from the Image
     */
    public void decode(){
        this.getOriginalSecretMessageLength_FROM_Image();
        this.decodeMessageBinaryFromImage();
    }

    /**
     * @description This strips the Binary of the Secret Message from the Image,processes it and
     *              passes it to decodeMsgFromBinary()
     */
    private void decodeMessageBinaryFromImage(){
        int retrieved = 0;
        StringBuilder sb = new StringBuilder();
        for(int row = 0 ; row <= (this.coverImage_rows - 1) -1 ; row++){
            for(int col = 0 ; col<= (this.coverImage_columns -1) ; col++){
                if(retrieved == this.originalSecretMessageLength*8){
                    this.secretMessage = this.decodeMsgFromBinary(sb.toString());
                    Log.i("URI","FOund MSG:"+this.secretMessage);
                    return;
                }
                //                get current RED Pixel Intensity
                int red = Color.red(this.coverImage.getPixel(col , row));

                //              GETTING ORIGINAL Binary of RED Channel
                String original = return8BinaryOfAscii(red);
                Log.i("URI" , "Original("+col+","+row+") =>"+original);

                String newLSBBits = original.substring(original.length()-2 , original.length());

                StringBuilder flip = new StringBuilder();
                if(newLSBBits.charAt(0)=='0'){
                    flip.append("1");
                }else{
                    flip.append("0");
                }

                if(newLSBBits.charAt(1)=='0'){
                    flip.append("1");
                }else{
                    flip.append("0");
                }

                newLSBBits = flip.toString();

                sb.append(newLSBBits);
                retrieved += 2;
            }
        }
    }

    /**
     *
     * @param binary  Binary form of the Secret Message
     * @return Returns the Secret Message corresponding to the given Binary
     */
    private String decodeMsgFromBinary(String binary){
        StringBuilder sb = new StringBuilder();
        for(int i=0 ; i<= (binary.length() -8) ; i+=8 ){
            String charBinary = binary.substring(i , i+8);
            sb.append(new Character( (char) Integer.parseInt(charBinary , 2) ).toString());
        }

        return sb.toString();
    }

    /**
     *@description This method should be called for Encoding the Message into the Image
     *              Before Encoding,we should Check whether the message can be Encoded or not
     *              by calling checkEncodability()
     */
    public void encode(){
        this.encodeMessage();
        this.encodeMessageLength();
    }

    /**
     * @description This retrieves the length of the Encoded Secret Message from the Encoded Image
     */
    private void getOriginalSecretMessageLength_FROM_Image(){
        StringBuilder sb = new StringBuilder();
        for(int col = 0; col<= this.coverImage_columns-1 ; col++){
            //                get current Pixel Intensities
            int alpha = Color.alpha(this.coverImage.getPixel(col , this.coverImage_rows -1));
            int red = Color.red(this.coverImage.getPixel(col , this.coverImage_rows -1));
            int green = Color.green(this.coverImage.getPixel(col , this.coverImage_rows -1));
            int blue = Color.blue(this.coverImage.getPixel(col , this.coverImage_rows -1));

            //              GETTING ORIGINAL Binary of RED Channel
            String original = return8BinaryOfAscii(red);

            sb.append(original.substring(original.length()-2 , original.length()));
        }
        Log.i("URI" , "LENGHT FOUND:" + Integer.parseInt(sb.toString() , 2));
        this.originalSecretMessageLength = Integer.parseInt(sb.toString() , 2);
    }

    /**
     * @description This encodes the Length of the Secret Message in the last row of the Image.
     */
    private void encodeMessageLength(){
        String originalBinary_OF_MsgLength = Integer.toBinaryString(this.originalSecretMessageLength);
        String encodableBinary = this.getEncodableBinaryOfMsgLengthBinary(originalBinary_OF_MsgLength);
        int count = 0;
        int remaining = encodableBinary.length();
        for(int col = 0 ; col <= this.coverImage_columns -1 ; col++){
            if(count > remaining - 2){
                return;
            }

            //                get current Pixel Intensities
            int alpha = Color.alpha(this.coverImage.getPixel(col , this.coverImage_rows -1));
            int red = Color.red(this.coverImage.getPixel(col , this.coverImage_rows -1));
            int green = Color.green(this.coverImage.getPixel(col , this.coverImage_rows -1));
            int blue = Color.blue(this.coverImage.getPixel(col , this.coverImage_rows -1));

            //              GETTING ORIGINAL Binary of RED Channel
            String original = return8BinaryOfAscii(red);
            Log.i("URI" , "Original("+col+","+(this.coverImage_rows -1)+") =>"+original);

            //                Get Modified String by Changing LSB 2 Bits
            String newLSBBits = encodableBinary.substring(count , count +2);
            count += 2;

            Log.i("URI" , "New LSBs("+col+","+(this.coverImage_rows -1)+") =>"+newLSBBits);


            String modified = original.substring(0 , original.length() - 2) + newLSBBits;

            Log.i("URI" , "Modified("+col+","+(this.coverImage_rows -1)+") =>"+modified);

            int modifiedRed = Integer.valueOf(modified , 2);


//                Writing Pixel Back
            this.coverImage.setHasAlpha(false);
            this.coverImage.setPixel(col , this.coverImage_rows -1 , Color.argb(alpha , modifiedRed , green , blue));

        }
    }

    /**
     *
     * @param originalBinary  The Binary of the Length_OF_Secret_Message
     * @return  Returns the Binary String,which can be used to encode directly
     */
    private String getEncodableBinaryOfMsgLengthBinary(String originalBinary){
        return String.join("" , Collections.nCopies(
                (this.coverImage_columns * 2 - (originalBinary.length())), "0")) + originalBinary;
    }

    /**
     * @description This method encodes the Secret message into the image
     */
    private void encodeMessage(){
        int count = 0;
        int remaining = this.Binary_OF_SecretMessage.length();
        for(int row = 0 ; row <= (this.coverImage_rows - 1) -1 ; row++){
            for(int col = 0 ; col<= (this.coverImage_columns -1) ; col++){

                if(count > remaining - 2){
                    return;
                }

                //                get current Pixel Intensities
                int alpha = Color.alpha(this.coverImage.getPixel(col , row));
                int red = Color.red(this.coverImage.getPixel(col , row));
                int green = Color.green(this.coverImage.getPixel(col , row));
                int blue = Color.blue(this.coverImage.getPixel(col , row));

//              GETTING ORIGINAL Binary of RED Channel
                String original = return8BinaryOfAscii(red);
                Log.i("URI" , "Original("+col+","+row+") =>"+original);

//                Get Modified String by Changing LSB 2 Bits
                String newLSBBits = this.Binary_OF_SecretMessage.substring(count , count +2);
                count += 2;

                StringBuilder flip = new StringBuilder();
                if(newLSBBits.charAt(0)=='0'){
                    flip.append("1");
                }else{
                    flip.append("0");
                }

                if(newLSBBits.charAt(1)=='0'){
                    flip.append("1");
                }else{
                    flip.append("0");
                }

                newLSBBits = flip.toString();

                Log.i("URI" , "New LSBs("+col+","+row+") =>"+newLSBBits);


                String modified = original.substring(0 , original.length() - 2) + newLSBBits;

                Log.i("URI" , "Modified("+col+","+row+") =>"+modified);

                int modifiedRed = Integer.valueOf(modified , 2);

//                Writing Pixel Back
                this.coverImage.setHasAlpha(false);
                this.coverImage.setPixel(col , row , Color.argb(alpha , modifiedRed , green , blue));
            }
        }
    }

    /**
     *
     * @return Returns true,if the given secret message can be encoded into the given Image.If
     *          not,it returns false.
     */
    public boolean checkEncodability(){
        return this.Binary_OF_SecretMessage.length() <= ((this.coverImage_rows - 1)*this.coverImage_columns*2 ) ;
    }

    /**
     * @description This makes Binary String corresponding to the Secret Message
     */
    private void makeBinaryStringFromMessage(){
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<= this.originalSecretMessageLength-1 ; i++){
            int ascii = (int) this.secretMessage.charAt(i);
            sb.append(this.return8BinaryOfAscii(ascii));
        }
        this.Binary_OF_SecretMessage = sb.toString();
        Log.i("URI" ,"BINARY MESSAGE:"+ this.Binary_OF_SecretMessage);
    }

    /**
     *
     * @param ascii ascii or Unicode of a character
     * @return Returns corresponding 8-bit Binary corresponding to the ascii or unicode
     */
    private String return8BinaryOfAscii(int ascii){
        String binary = Integer.toBinaryString(ascii);
        return String.join("" , Collections.nCopies(8-(binary.length()) , "0")) + binary;
    }
}
